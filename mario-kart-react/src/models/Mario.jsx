/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/Mario.glb 
*/

import React, { useEffect, useState } from 'react'
import { useGraph, useFrame } from '@react-three/fiber'
import { useGLTF } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import { MathUtils, DoubleSide } from 'three'

export function Mario({ steer, drift, isSelection = false, ...props }) {
  const { scene } = useGLTF('/Mario.glb')
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)

  // Mappa delle ossa principali (Da adattare se i nomi nel tuo GLB sono diversi)
  const [bones, setBones] = useState({
    hips: null,
    thighL: null, thighR: null,
    shinL: null, shinR: null,
    armL: null, armR: null,
    spine: null
  })

  useEffect(() => {
    // 1. Setup Materiali
    scene.traverse((object) => {
      if (object.isMesh) {
        object.material.side = DoubleSide
        object.castShadow = true
        object.receiveShadow = true
        object.material.transparent = false 
        object.material.depthWrite = true
      }
    })

    // 2. Trova le ossa (Debug: guarda la console per i nomi esatti se non funziona)
    // console.log("Ossa disponibili:", Object.keys(nodes))
    
    // Helper per trovare ossa case-insensitive o con nomi vari
    const find = (names) => {
        for (let name of names) {
            // Cerca match esatto o parziale
            const key = Object.keys(nodes).find(n => n.toLowerCase().includes(name.toLowerCase()) && nodes[n].isBone)
            if (key) return nodes[key]
        }
        return null
    }

    setBones({
        hips: find(['Hip', 'Waist', 'Pelvis']),
        thighL: find(['Thigh_L', 'Leg_L', 'UpLeg_L']),
        thighR: find(['Thigh_R', 'Leg_R', 'UpLeg_R']),
        shinL: find(['Shin_L', 'Knee_L', 'Leg_L_2']),
        shinR: find(['Shin_R', 'Knee_R', 'Leg_R_2']),
        armL: find(['Arm_L', 'Shoulder_L', 'UpperArm_L']),
        armR: find(['Arm_R', 'Shoulder_R', 'UpperArm_R']),
        spine: find(['Spine', 'Body']),
    })

  }, [scene, nodes])

  useFrame((state, delta) => {
    
    // --- MODALITÀ SELEZIONE (T-POSE / IN PIEDI) ---
    if (isSelection) {
        // Resetta le rotazioni per farlo stare dritto
        const tPoseSpeed = 8

        // 1. Gambe dritte (Rimuovi la piega da seduto)
        if (bones.thighL) bones.thighL.rotation.x = MathUtils.damp(bones.thighL.rotation.x, 0, tPoseSpeed, delta)
        if (bones.thighR) bones.thighR.rotation.x = MathUtils.damp(bones.thighR.rotation.x, 0, tPoseSpeed, delta)
        
        // 2. Ginocchia dritte
        if (bones.shinL) bones.shinL.rotation.x = MathUtils.damp(bones.shinL.rotation.x, 0, tPoseSpeed, delta)
        if (bones.shinR) bones.shinR.rotation.x = MathUtils.damp(bones.shinR.rotation.x, 0, tPoseSpeed, delta)

        // 3. Braccia aperte (A-Pose o T-Pose)
        // 0 solitamente è T-Pose, 0.5-0.8 è A-Pose (più naturale)
        if (bones.armL) {
             bones.armL.rotation.z = MathUtils.damp(bones.armL.rotation.z, 0.3, tPoseSpeed, delta) // Abbassa un po' le braccia
             bones.armL.rotation.x = MathUtils.damp(bones.armL.rotation.x, 0, tPoseSpeed, delta)
             bones.armL.rotation.y = MathUtils.damp(bones.armL.rotation.y, 0, tPoseSpeed, delta)
        }
        if (bones.armR) {
             bones.armR.rotation.z = MathUtils.damp(bones.armR.rotation.z, -0.3, tPoseSpeed, delta)
             bones.armR.rotation.x = MathUtils.damp(bones.armR.rotation.x, 0, tPoseSpeed, delta)
             bones.armR.rotation.y = MathUtils.damp(bones.armR.rotation.y, 0, tPoseSpeed, delta)
        }
        
        // 4. Reset rotazione corpo principale
        if (nodes.mario_body) {
            nodes.mario_body.rotation.y = MathUtils.damp(nodes.mario_body.rotation.y, 0, tPoseSpeed, delta)
            // Alzalo un po' se quando si alza i piedi finiscono sotto terra
            // nodes.mario_body.position.y = MathUtils.damp(nodes.mario_body.position.y, 0, tPoseSpeed, delta)
        }
        
        return // Esce qui, non esegue la logica di guida
    }

    // --- MODALITÀ GUIDA (LOGICA ORIGINALE) ---
    
    // Se non è in selezione, le ossa seguono l'animazione originale del GLB (seduto)
    // O possiamo forzarlo a sedersi qui se il GLB fosse in T-Pose di default.
    // Assumiamo che il GLB di base sia già seduto.

    let targetLean = -steer * 0.5
    if (drift !== 0) {
      targetLean = drift === 1 ? -0.8 : 0.8
    }
    if (nodes.mario_body) {
      nodes.mario_body.rotation.y = MathUtils.damp(nodes.mario_body.rotation.y, targetLean, 4, delta)
    }
  })

  return (
    <group {...props} dispose={null}>
      <group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
        <primitive object={nodes.mario_body} />
        <skinnedMesh geometry={nodes.polygon0.geometry} material={materials.mario_all_tx} skeleton={nodes.polygon0.skeleton} />
        <skinnedMesh geometry={nodes.polygon1.geometry} material={materials.mario_eye_tx} skeleton={nodes.polygon1.skeleton} />
      </group>
    </group>
  )
}

useGLTF.preload('/Mario.glb')