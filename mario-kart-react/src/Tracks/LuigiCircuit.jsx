/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/LuigiCircuit.glb 
*/

import React, { useLayoutEffect, useRef, useMemo } from 'react'
import { useGraph } from '@react-three/fiber'
import { useGLTF } from '@react-three/drei'
import { SkeletonUtils, mergeVertices } from 'three-stdlib'
import { useTrimesh } from '@react-three/cannon'

// --- ðŸ”§ REGOLA LA GRANDEZZA QUI ---
const trackScale = 0.011 

export function LuigiCircuit(props) {
  const { scene } = useGLTF('/LuigiCircuit.glb')
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene])
  const { nodes, materials } = useGraph(clone)

  const groupRef = useRef()

  // FIX GRAFICA: Frustum Culling e Ombre
  useLayoutEffect(() => {
    if (groupRef.current) {
      groupRef.current.traverse((object) => {
        object.frustumCulled = false
        object.castShadow = true
        object.receiveShadow = true
        
        // Reset bounding box per evitare flicker
        if (object.isSkinnedMesh || object.isMesh) {
           if (object.geometry) {
             object.geometry.boundingSphere = null
             object.geometry.boundingBox = null
           }
        }
      })
    }
  }, [])

  const trackPosition = props.position || [0, 0, 0]

  // --- CONFIGURAZIONE FISICA ---
  const colliderProps = {
    type: 'Static',
    // âš ï¸ FONDAMENTALE: La rotazione DEVE essere attiva per combaciare con la grafica!
    //rotation: [Math.PI / 2, 0, 0], 
    
    // Scala sincronizzata
    scale: [trackScale, trackScale, trackScale],
    
    position: trackPosition,
  }

  // --- FUNZIONE PER LISCIARE LE HITBOX ---
  // Unisce i vertici per evitare che la sfera passi attraverso le fessure dei triangoli
  const createSmootherGeometry = (geometry) => {
    const tempGeo = geometry.clone()
    const mergedGeo = mergeVertices(tempGeo) 
    return [mergedGeo.attributes.position.array, mergedGeo.index.array]
  }

  // 1. ASFALTO
  const [roadGeo, roadIndex] = useMemo(() => createSmootherGeometry(nodes.polygon8.geometry), [nodes.polygon8])
  useTrimesh(() => ({ args: [roadGeo, roadIndex], ...colliderProps, friction: 0.02, restitution: 0 }))

  // 2. FUORI PISTA (Sabbia)
  const [sandGeo, sandIndex] = useMemo(() => createSmootherGeometry(nodes.polygon5.geometry), [nodes.polygon5])
  useTrimesh(() => ({ args: [sandGeo, sandIndex], ...colliderProps, friction: 2.0 }))

  // 3. ERBA
  const [grass1Geo, grass1Index] = useMemo(() => createSmootherGeometry(nodes.polygon3.geometry), [nodes.polygon3])
  useTrimesh(() => ({ args: [grass1Geo, grass1Index], ...colliderProps, friction: 0.5 }))

  const [grass2Geo, grass2Index] = useMemo(() => createSmootherGeometry(nodes.polygon2.geometry), [nodes.polygon2])
  useTrimesh(() => ({ args: [grass2Geo, grass2Index], ...colliderProps, friction: 0.5 }))

  // 4. MURI (Polygon 20)
  // ORA APPLICHIAMO IL MERGE ANCHE AI MURI
  // Questo impedisce alla sfera di passare attraverso le giunture dei muri
  const [wallGeo, wallIndex] = useMemo(() => createSmootherGeometry(nodes.polygon20.geometry), [nodes.polygon20])
  useTrimesh(() => ({
    args: [wallGeo, wallIndex],
    ...colliderProps,
    friction: 0.0, // Scivola sui muri
    restitution: 0.5, // Rimbalza un po'
  }))

  // 5. CORDOLI
  const [curbGeo, curbIndex] = useMemo(() => createSmootherGeometry(nodes.polygon1.geometry), [nodes.polygon1])
  useTrimesh(() => ({ args: [curbGeo, curbIndex], ...colliderProps }))

  return (
    <group ref={groupRef} {...props} dispose={null}>
      {/* GRUPPO VISIVO: Ruotato come la fisica */}
      <group rotation={[Math.PI / 2, 0, 0]} scale={trackScale}>
        <primitive object={nodes.beginner_course} />
        
        <skinnedMesh geometry={nodes.polygon0.geometry} material={materials.ef_dushBoard} skeleton={nodes.polygon0.skeleton} />
        <skinnedMesh geometry={nodes.polygon1.geometry} material={materials.a_bc_enseki_m} skeleton={nodes.polygon1.skeleton} />
        <skinnedMesh geometry={nodes.polygon101.geometry} material={materials.lugcap_m} skeleton={nodes.polygon101.skeleton} />
        <skinnedMesh geometry={nodes.polygon106.geometry} material={materials.bc_spot_m} skeleton={nodes.polygon106.skeleton} />
        <skinnedMesh geometry={nodes.polygon116.geometry} material={materials.lake_m} skeleton={nodes.polygon116.skeleton} />
        <skinnedMesh geometry={nodes.polygon117.geometry} material={materials.yama_m} skeleton={nodes.polygon117.skeleton} />
        <skinnedMesh geometry={nodes.polygon17.geometry} material={materials.bc_kankyaku_m} skeleton={nodes.polygon17.skeleton} />
        <skinnedMesh geometry={nodes.polygon1b.geometry} material={materials.shadow} skeleton={nodes.polygon1b.skeleton} />
        <skinnedMesh geometry={nodes.polygon2.geometry} material={materials.a_kusa_soto} skeleton={nodes.polygon2.skeleton} />
        <skinnedMesh geometry={nodes.polygon20.geometry} material={materials.fence} skeleton={nodes.polygon20.skeleton} />
        <skinnedMesh geometry={nodes.polygon22.geometry} material={materials.popkanban_m} skeleton={nodes.polygon22.skeleton} />
        <skinnedMesh geometry={nodes.polygon23.geometry} material={materials.kusa_kanban_m} skeleton={nodes.polygon23.skeleton} />
        <skinnedMesh geometry={nodes.polygon27.geometry} material={materials.a_bc_kankyakuseat_m} skeleton={nodes.polygon27.skeleton} />
        <skinnedMesh geometry={nodes.polygon27b.geometry} material={materials.shadow} skeleton={nodes.polygon27b.skeleton} />
        <skinnedMesh geometry={nodes.polygon2b.geometry} material={materials.shadow} skeleton={nodes.polygon2b.skeleton} />
        <skinnedMesh geometry={nodes.polygon3.geometry} material={materials.a_kusa_waki_m} skeleton={nodes.polygon3.skeleton} />
        <skinnedMesh geometry={nodes.polygon38.geometry} material={materials.enkei_yama_m} skeleton={nodes.polygon38.skeleton} />
        <skinnedMesh geometry={nodes.polygon39.geometry} material={materials.kinoko_m} skeleton={nodes.polygon39.skeleton} />
        <skinnedMesh geometry={nodes.polygon3b.geometry} material={materials.shadow} skeleton={nodes.polygon3b.skeleton} />
        <skinnedMesh geometry={nodes.polygon4.geometry} material={materials.block3_m} skeleton={nodes.polygon4.skeleton} />
        <skinnedMesh geometry={nodes.polygon5.geometry} material={materials.a_SAND_m} skeleton={nodes.polygon5.skeleton} />
        <skinnedMesh geometry={nodes.polygon5b.geometry} material={materials.shadow} skeleton={nodes.polygon5b.skeleton} />
        <skinnedMesh geometry={nodes.polygon6.geometry} material={materials.tatemono_m} skeleton={nodes.polygon6.skeleton} />
        <skinnedMesh geometry={nodes.polygon76.geometry} material={materials.WT_EleArrow_ALL} skeleton={nodes.polygon76.skeleton} />
        <skinnedMesh geometry={nodes.polygon8.geometry} material={materials.a_MainRoad_m} skeleton={nodes.polygon8.skeleton} />
        <skinnedMesh geometry={nodes.polygon8b.geometry} material={materials.shadow} skeleton={nodes.polygon8b.skeleton} />
        <skinnedMesh geometry={nodes.polygon93.geometry} material={materials.hana_m} skeleton={nodes.polygon93.skeleton} />
        <skinnedMesh geometry={nodes.polygon99.geometry} material={materials.bc_tree_one_m} skeleton={nodes.polygon99.skeleton} />
      </group>
    </group>
  )
}

useGLTF.preload('/LuigiCircuit.glb')